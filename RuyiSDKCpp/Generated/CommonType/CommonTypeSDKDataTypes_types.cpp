/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "CommonTypeSDKDataTypes_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Ruyi { namespace SDK { namespace CommonType {

int _kInputCagetoryValues[] = {
  InputCagetory::RuyiGamePad,
  InputCagetory::KeyboardMouse,
  InputCagetory::XBox360
};
const char* _kInputCagetoryNames[] = {
  "RuyiGamePad",
  "KeyboardMouse",
  "XBox360"
};
const std::map<int, const char*> _InputCagetory_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kInputCagetoryValues, _kInputCagetoryNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kePlatformValues[] = {
  ePlatform::None,
  ePlatform::PC,
  ePlatform::Console,
  ePlatform::All
};
const char* _kePlatformNames[] = {
  "None",
  "PC",
  "Console",
  "All"
};
const std::map<int, const char*> _ePlatform_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kePlatformValues, _kePlatformNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _keUITypeValues[] = {
  eUIType::None,
  eUIType::Toggle,
  eUIType::Text,
  eUIType::Slider,
  eUIType::CheckList,
  eUIType::OptionList,
  eUIType::DateTime,
  eUIType::TextInput
};
const char* _keUITypeNames[] = {
  "None",
  "Toggle",
  "Text",
  "Slider",
  "CheckList",
  "OptionList",
  "DateTime",
  "TextInput"
};
const std::map<int, const char*> _eUIType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _keUITypeValues, _keUITypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


ErrorException::~ErrorException() throw() {
}


void ErrorException::__set_errId(const int32_t val) {
  this->errId = val;
}

void ErrorException::__set_errMsg(const std::string& val) {
  this->errMsg = val;
}

uint32_t ErrorException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errId);
          this->__isset.errId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errMsg);
          this->__isset.errMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ErrorException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ErrorException");

  xfer += oprot->writeFieldBegin("errId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->errId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("errMsg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->errMsg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ErrorException &a, ErrorException &b) {
  using ::std::swap;
  swap(a.errId, b.errId);
  swap(a.errMsg, b.errMsg);
  swap(a.__isset, b.__isset);
}

ErrorException::ErrorException(const ErrorException& other0) : TException() {
  errId = other0.errId;
  errMsg = other0.errMsg;
  __isset = other0.__isset;
}
ErrorException& ErrorException::operator=(const ErrorException& other1) {
  errId = other1.errId;
  errMsg = other1.errMsg;
  __isset = other1.__isset;
  return *this;
}
void ErrorException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ErrorException(";
  out << "errId=" << to_string(errId);
  out << ", " << "errMsg=" << to_string(errMsg);
  out << ")";
}

const char* ErrorException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ErrorException";
  }
}


range::~range() throw() {
}


void range::__set_minimum(const double val) {
  this->minimum = val;
}

void range::__set_maximum(const double val) {
  this->maximum = val;
}

uint32_t range::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->minimum);
          this->__isset.minimum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->maximum);
          this->__isset.maximum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t range::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("range");

  xfer += oprot->writeFieldBegin("minimum", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->minimum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maximum", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->maximum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(range &a, range &b) {
  using ::std::swap;
  swap(a.minimum, b.minimum);
  swap(a.maximum, b.maximum);
  swap(a.__isset, b.__isset);
}

range::range(const range& other2) {
  minimum = other2.minimum;
  maximum = other2.maximum;
  __isset = other2.__isset;
}
range& range::operator=(const range& other3) {
  minimum = other3.minimum;
  maximum = other3.maximum;
  __isset = other3.__isset;
  return *this;
}
void range::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "range(";
  out << "minimum=" << to_string(minimum);
  out << ", " << "maximum=" << to_string(maximum);
  out << ")";
}


InputModifier::~InputModifier() throw() {
}


void InputModifier::__set_DeadZone(const range& val) {
  this->DeadZone = val;
__isset.DeadZone = true;
}

void InputModifier::__set_Scale(const double val) {
  this->Scale = val;
}

uint32_t InputModifier::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->DeadZone.read(iprot);
          this->__isset.DeadZone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Scale);
          this->__isset.Scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InputModifier::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InputModifier");

  if (this->__isset.DeadZone) {
    xfer += oprot->writeFieldBegin("DeadZone", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->DeadZone.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("Scale", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Scale);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InputModifier &a, InputModifier &b) {
  using ::std::swap;
  swap(a.DeadZone, b.DeadZone);
  swap(a.Scale, b.Scale);
  swap(a.__isset, b.__isset);
}

InputModifier::InputModifier(const InputModifier& other4) {
  DeadZone = other4.DeadZone;
  Scale = other4.Scale;
  __isset = other4.__isset;
}
InputModifier& InputModifier::operator=(const InputModifier& other5) {
  DeadZone = other5.DeadZone;
  Scale = other5.Scale;
  __isset = other5.__isset;
  return *this;
}
void InputModifier::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InputModifier(";
  out << "DeadZone="; (__isset.DeadZone ? (out << to_string(DeadZone)) : (out << "<null>"));
  out << ", " << "Scale=" << to_string(Scale);
  out << ")";
}


InputIdentifier::~InputIdentifier() throw() {
}


void InputIdentifier::__set_Device(const std::string& val) {
  this->Device = val;
}

void InputIdentifier::__set_Value(const std::string& val) {
  this->Value = val;
}

void InputIdentifier::__set_ActivateEvent(const std::string& val) {
  this->ActivateEvent = val;
__isset.ActivateEvent = true;
}

void InputIdentifier::__set_Modifier(const InputModifier& val) {
  this->Modifier = val;
__isset.Modifier = true;
}

uint32_t InputIdentifier::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Device);
          this->__isset.Device = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Value);
          this->__isset.Value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ActivateEvent);
          this->__isset.ActivateEvent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Modifier.read(iprot);
          this->__isset.Modifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InputIdentifier::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InputIdentifier");

  xfer += oprot->writeFieldBegin("Device", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Device);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->Value);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ActivateEvent) {
    xfer += oprot->writeFieldBegin("ActivateEvent", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->ActivateEvent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Modifier) {
    xfer += oprot->writeFieldBegin("Modifier", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->Modifier.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InputIdentifier &a, InputIdentifier &b) {
  using ::std::swap;
  swap(a.Device, b.Device);
  swap(a.Value, b.Value);
  swap(a.ActivateEvent, b.ActivateEvent);
  swap(a.Modifier, b.Modifier);
  swap(a.__isset, b.__isset);
}

InputIdentifier::InputIdentifier(const InputIdentifier& other6) {
  Device = other6.Device;
  Value = other6.Value;
  ActivateEvent = other6.ActivateEvent;
  Modifier = other6.Modifier;
  __isset = other6.__isset;
}
InputIdentifier& InputIdentifier::operator=(const InputIdentifier& other7) {
  Device = other7.Device;
  Value = other7.Value;
  ActivateEvent = other7.ActivateEvent;
  Modifier = other7.Modifier;
  __isset = other7.__isset;
  return *this;
}
void InputIdentifier::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InputIdentifier(";
  out << "Device=" << to_string(Device);
  out << ", " << "Value=" << to_string(Value);
  out << ", " << "ActivateEvent="; (__isset.ActivateEvent ? (out << to_string(ActivateEvent)) : (out << "<null>"));
  out << ", " << "Modifier="; (__isset.Modifier ? (out << to_string(Modifier)) : (out << "<null>"));
  out << ")";
}


ActionTriggerInfo::~ActionTriggerInfo() throw() {
}


void ActionTriggerInfo::__set_InputCagetory(const InputCagetory::type val) {
  this->InputCagetory = val;
}

void ActionTriggerInfo::__set_TriggerConditions(const std::vector<InputIdentifier> & val) {
  this->TriggerConditions = val;
}

void ActionTriggerInfo::__set_AutoTrigger(const bool val) {
  this->AutoTrigger = val;
__isset.AutoTrigger = true;
}

void ActionTriggerInfo::__set_TriggerInterval(const int32_t val) {
  this->TriggerInterval = val;
__isset.TriggerInterval = true;
}

uint32_t ActionTriggerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->InputCagetory = (InputCagetory::type)ecast8;
          this->__isset.InputCagetory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->TriggerConditions.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _etype12;
            xfer += iprot->readListBegin(_etype12, _size9);
            this->TriggerConditions.resize(_size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              xfer += this->TriggerConditions[_i13].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.TriggerConditions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->AutoTrigger);
          this->__isset.AutoTrigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->TriggerInterval);
          this->__isset.TriggerInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionTriggerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionTriggerInfo");

  xfer += oprot->writeFieldBegin("InputCagetory", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->InputCagetory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TriggerConditions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->TriggerConditions.size()));
    std::vector<InputIdentifier> ::const_iterator _iter14;
    for (_iter14 = this->TriggerConditions.begin(); _iter14 != this->TriggerConditions.end(); ++_iter14)
    {
      xfer += (*_iter14).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.AutoTrigger) {
    xfer += oprot->writeFieldBegin("AutoTrigger", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->AutoTrigger);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.TriggerInterval) {
    xfer += oprot->writeFieldBegin("TriggerInterval", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->TriggerInterval);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionTriggerInfo &a, ActionTriggerInfo &b) {
  using ::std::swap;
  swap(a.InputCagetory, b.InputCagetory);
  swap(a.TriggerConditions, b.TriggerConditions);
  swap(a.AutoTrigger, b.AutoTrigger);
  swap(a.TriggerInterval, b.TriggerInterval);
  swap(a.__isset, b.__isset);
}

ActionTriggerInfo::ActionTriggerInfo(const ActionTriggerInfo& other15) {
  InputCagetory = other15.InputCagetory;
  TriggerConditions = other15.TriggerConditions;
  AutoTrigger = other15.AutoTrigger;
  TriggerInterval = other15.TriggerInterval;
  __isset = other15.__isset;
}
ActionTriggerInfo& ActionTriggerInfo::operator=(const ActionTriggerInfo& other16) {
  InputCagetory = other16.InputCagetory;
  TriggerConditions = other16.TriggerConditions;
  AutoTrigger = other16.AutoTrigger;
  TriggerInterval = other16.TriggerInterval;
  __isset = other16.__isset;
  return *this;
}
void ActionTriggerInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionTriggerInfo(";
  out << "InputCagetory=" << to_string(InputCagetory);
  out << ", " << "TriggerConditions=" << to_string(TriggerConditions);
  out << ", " << "AutoTrigger="; (__isset.AutoTrigger ? (out << to_string(AutoTrigger)) : (out << "<null>"));
  out << ", " << "TriggerInterval="; (__isset.TriggerInterval ? (out << to_string(TriggerInterval)) : (out << "<null>"));
  out << ")";
}


InputActionInfo::~InputActionInfo() throw() {
}


void InputActionInfo::__set_ActionName(const std::string& val) {
  this->ActionName = val;
}

void InputActionInfo::__set_TriggerInfo(const ActionTriggerInfo& val) {
  this->TriggerInfo = val;
}

uint32_t InputActionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ActionName);
          this->__isset.ActionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->TriggerInfo.read(iprot);
          this->__isset.TriggerInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InputActionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InputActionInfo");

  xfer += oprot->writeFieldBegin("ActionName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ActionName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TriggerInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->TriggerInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InputActionInfo &a, InputActionInfo &b) {
  using ::std::swap;
  swap(a.ActionName, b.ActionName);
  swap(a.TriggerInfo, b.TriggerInfo);
  swap(a.__isset, b.__isset);
}

InputActionInfo::InputActionInfo(const InputActionInfo& other17) {
  ActionName = other17.ActionName;
  TriggerInfo = other17.TriggerInfo;
  __isset = other17.__isset;
}
InputActionInfo& InputActionInfo::operator=(const InputActionInfo& other18) {
  ActionName = other18.ActionName;
  TriggerInfo = other18.TriggerInfo;
  __isset = other18.__isset;
  return *this;
}
void InputActionInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InputActionInfo(";
  out << "ActionName=" << to_string(ActionName);
  out << ", " << "TriggerInfo=" << to_string(TriggerInfo);
  out << ")";
}


notification::~notification() throw() {
}


void notification::__set_title(const std::string& val) {
  this->title = val;
}

void notification::__set_detail(const std::string& val) {
  this->detail = val;
}

void notification::__set_option(const std::vector<std::string> & val) {
  this->option = val;
}

uint32_t notification::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->detail);
          this->__isset.detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->option.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->option.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += iprot->readString(this->option[_i23]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t notification::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("notification");

  xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->title);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("detail", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->detail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("option", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->option.size()));
    std::vector<std::string> ::const_iterator _iter24;
    for (_iter24 = this->option.begin(); _iter24 != this->option.end(); ++_iter24)
    {
      xfer += oprot->writeString((*_iter24));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(notification &a, notification &b) {
  using ::std::swap;
  swap(a.title, b.title);
  swap(a.detail, b.detail);
  swap(a.option, b.option);
  swap(a.__isset, b.__isset);
}

notification::notification(const notification& other25) {
  title = other25.title;
  detail = other25.detail;
  option = other25.option;
  __isset = other25.__isset;
}
notification& notification::operator=(const notification& other26) {
  title = other26.title;
  detail = other26.detail;
  option = other26.option;
  __isset = other26.__isset;
  return *this;
}
void notification::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "notification(";
  out << "title=" << to_string(title);
  out << ", " << "detail=" << to_string(detail);
  out << ", " << "option=" << to_string(option);
  out << ")";
}


dataListItem::~dataListItem() throw() {
}


void dataListItem::__set_elementType(const std::string& val) {
  this->elementType = val;
}

void dataListItem::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void dataListItem::__set_removeNotification(const notification& val) {
  this->removeNotification = val;
}

uint32_t dataListItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->elementType);
          this->__isset.elementType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->values.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += iprot->readString(this->values[_i31]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->removeNotification.read(iprot);
          this->__isset.removeNotification = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t dataListItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("dataListItem");

  xfer += oprot->writeFieldBegin("elementType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->elementType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter32;
    for (_iter32 = this->values.begin(); _iter32 != this->values.end(); ++_iter32)
    {
      xfer += oprot->writeString((*_iter32));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("removeNotification", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->removeNotification.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(dataListItem &a, dataListItem &b) {
  using ::std::swap;
  swap(a.elementType, b.elementType);
  swap(a.values, b.values);
  swap(a.removeNotification, b.removeNotification);
  swap(a.__isset, b.__isset);
}

dataListItem::dataListItem(const dataListItem& other33) {
  elementType = other33.elementType;
  values = other33.values;
  removeNotification = other33.removeNotification;
  __isset = other33.__isset;
}
dataListItem& dataListItem::operator=(const dataListItem& other34) {
  elementType = other34.elementType;
  values = other34.values;
  removeNotification = other34.removeNotification;
  __isset = other34.__isset;
  return *this;
}
void dataListItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "dataListItem(";
  out << "elementType=" << to_string(elementType);
  out << ", " << "values=" << to_string(values);
  out << ", " << "removeNotification=" << to_string(removeNotification);
  out << ")";
}


activeDependency::~activeDependency() throw() {
}


void activeDependency::__set_name(const std::string& val) {
  this->name = val;
}

void activeDependency::__set_condition(const std::string& val) {
  this->condition = val;
}

uint32_t activeDependency::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->condition);
          this->__isset.condition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t activeDependency::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("activeDependency");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("condition", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->condition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(activeDependency &a, activeDependency &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.condition, b.condition);
  swap(a.__isset, b.__isset);
}

activeDependency::activeDependency(const activeDependency& other35) {
  name = other35.name;
  condition = other35.condition;
  __isset = other35.__isset;
}
activeDependency& activeDependency::operator=(const activeDependency& other36) {
  name = other36.name;
  condition = other36.condition;
  __isset = other36.__isset;
  return *this;
}
void activeDependency::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "activeDependency(";
  out << "name=" << to_string(name);
  out << ", " << "condition=" << to_string(condition);
  out << ")";
}


SettingItem::~SettingItem() throw() {
}


void SettingItem::__set_id(const std::string& val) {
  this->id = val;
}

void SettingItem::__set_display(const std::string& val) {
  this->display = val;
}

void SettingItem::__set_dataType(const std::string& val) {
  this->dataType = val;
}

void SettingItem::__set_dataValue(const std::string& val) {
  this->dataValue = val;
}

void SettingItem::__set_dataList(const dataListItem& val) {
  this->dataList = val;
__isset.dataList = true;
}

void SettingItem::__set_platform(const ePlatform::type val) {
  this->platform = val;
__isset.platform = true;
}

void SettingItem::__set_summary(const std::string& val) {
  this->summary = val;
__isset.summary = true;
}

void SettingItem::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void SettingItem::__set_UIType(const eUIType::type val) {
  this->UIType = val;
__isset.UIType = true;
}

void SettingItem::__set_devModeOnly(const bool val) {
  this->devModeOnly = val;
__isset.devModeOnly = true;
}

void SettingItem::__set_internalOnly(const bool val) {
  this->internalOnly = val;
__isset.internalOnly = true;
}

void SettingItem::__set_readOnly(const bool val) {
  this->readOnly = val;
__isset.readOnly = true;
}

void SettingItem::__set_isValid(const bool val) {
  this->isValid = val;
}

void SettingItem::__set_isActive(const bool val) {
  this->isActive = val;
}

void SettingItem::__set_validation(const std::string& val) {
  this->validation = val;
__isset.validation = true;
}

void SettingItem::__set_activeDependencies(const std::vector<activeDependency> & val) {
  this->activeDependencies = val;
__isset.activeDependencies = true;
}

void SettingItem::__set_ActionName(const std::string& val) {
  this->ActionName = val;
}

void SettingItem::__set_ActionObject(const std::string& val) {
  this->ActionObject = val;
}

void SettingItem::__set_ActionMethodName(const std::string& val) {
  this->ActionMethodName = val;
}

uint32_t SettingItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->display);
          this->__isset.display = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataType);
          this->__isset.dataType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataValue);
          this->__isset.dataValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dataList.read(iprot);
          this->__isset.dataList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast37;
          xfer += iprot->readI32(ecast37);
          this->platform = (ePlatform::type)ecast37;
          this->__isset.platform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->summary);
          this->__isset.summary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast38;
          xfer += iprot->readI32(ecast38);
          this->UIType = (eUIType::type)ecast38;
          this->__isset.UIType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->devModeOnly);
          this->__isset.devModeOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->internalOnly);
          this->__isset.internalOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->readOnly);
          this->__isset.readOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isValid);
          this->__isset.isValid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isActive);
          this->__isset.isActive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validation);
          this->__isset.validation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->activeDependencies.clear();
            uint32_t _size39;
            ::apache::thrift::protocol::TType _etype42;
            xfer += iprot->readListBegin(_etype42, _size39);
            this->activeDependencies.resize(_size39);
            uint32_t _i43;
            for (_i43 = 0; _i43 < _size39; ++_i43)
            {
              xfer += this->activeDependencies[_i43].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.activeDependencies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ActionName);
          this->__isset.ActionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ActionObject);
          this->__isset.ActionObject = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ActionMethodName);
          this->__isset.ActionMethodName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SettingItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SettingItem");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("display", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->display);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->dataType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataValue", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->dataValue);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dataList) {
    xfer += oprot->writeFieldBegin("dataList", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->dataList.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platform) {
    xfer += oprot->writeFieldBegin("platform", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->platform);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.summary) {
    xfer += oprot->writeFieldBegin("summary", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->summary);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.UIType) {
    xfer += oprot->writeFieldBegin("UIType", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->UIType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.devModeOnly) {
    xfer += oprot->writeFieldBegin("devModeOnly", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->devModeOnly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.internalOnly) {
    xfer += oprot->writeFieldBegin("internalOnly", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->internalOnly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.readOnly) {
    xfer += oprot->writeFieldBegin("readOnly", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->readOnly);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("isValid", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->isValid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isActive", ::apache::thrift::protocol::T_BOOL, 14);
  xfer += oprot->writeBool(this->isActive);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validation) {
    xfer += oprot->writeFieldBegin("validation", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->validation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.activeDependencies) {
    xfer += oprot->writeFieldBegin("activeDependencies", ::apache::thrift::protocol::T_LIST, 16);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->activeDependencies.size()));
      std::vector<activeDependency> ::const_iterator _iter44;
      for (_iter44 = this->activeDependencies.begin(); _iter44 != this->activeDependencies.end(); ++_iter44)
      {
        xfer += (*_iter44).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("ActionName", ::apache::thrift::protocol::T_STRING, 17);
  xfer += oprot->writeString(this->ActionName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ActionObject", ::apache::thrift::protocol::T_STRING, 18);
  xfer += oprot->writeString(this->ActionObject);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ActionMethodName", ::apache::thrift::protocol::T_STRING, 19);
  xfer += oprot->writeString(this->ActionMethodName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SettingItem &a, SettingItem &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.display, b.display);
  swap(a.dataType, b.dataType);
  swap(a.dataValue, b.dataValue);
  swap(a.dataList, b.dataList);
  swap(a.platform, b.platform);
  swap(a.summary, b.summary);
  swap(a.description, b.description);
  swap(a.UIType, b.UIType);
  swap(a.devModeOnly, b.devModeOnly);
  swap(a.internalOnly, b.internalOnly);
  swap(a.readOnly, b.readOnly);
  swap(a.isValid, b.isValid);
  swap(a.isActive, b.isActive);
  swap(a.validation, b.validation);
  swap(a.activeDependencies, b.activeDependencies);
  swap(a.ActionName, b.ActionName);
  swap(a.ActionObject, b.ActionObject);
  swap(a.ActionMethodName, b.ActionMethodName);
  swap(a.__isset, b.__isset);
}

SettingItem::SettingItem(const SettingItem& other45) {
  id = other45.id;
  display = other45.display;
  dataType = other45.dataType;
  dataValue = other45.dataValue;
  dataList = other45.dataList;
  platform = other45.platform;
  summary = other45.summary;
  description = other45.description;
  UIType = other45.UIType;
  devModeOnly = other45.devModeOnly;
  internalOnly = other45.internalOnly;
  readOnly = other45.readOnly;
  isValid = other45.isValid;
  isActive = other45.isActive;
  validation = other45.validation;
  activeDependencies = other45.activeDependencies;
  ActionName = other45.ActionName;
  ActionObject = other45.ActionObject;
  ActionMethodName = other45.ActionMethodName;
  __isset = other45.__isset;
}
SettingItem& SettingItem::operator=(const SettingItem& other46) {
  id = other46.id;
  display = other46.display;
  dataType = other46.dataType;
  dataValue = other46.dataValue;
  dataList = other46.dataList;
  platform = other46.platform;
  summary = other46.summary;
  description = other46.description;
  UIType = other46.UIType;
  devModeOnly = other46.devModeOnly;
  internalOnly = other46.internalOnly;
  readOnly = other46.readOnly;
  isValid = other46.isValid;
  isActive = other46.isActive;
  validation = other46.validation;
  activeDependencies = other46.activeDependencies;
  ActionName = other46.ActionName;
  ActionObject = other46.ActionObject;
  ActionMethodName = other46.ActionMethodName;
  __isset = other46.__isset;
  return *this;
}
void SettingItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SettingItem(";
  out << "id=" << to_string(id);
  out << ", " << "display=" << to_string(display);
  out << ", " << "dataType=" << to_string(dataType);
  out << ", " << "dataValue=" << to_string(dataValue);
  out << ", " << "dataList="; (__isset.dataList ? (out << to_string(dataList)) : (out << "<null>"));
  out << ", " << "platform="; (__isset.platform ? (out << to_string(platform)) : (out << "<null>"));
  out << ", " << "summary="; (__isset.summary ? (out << to_string(summary)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "UIType="; (__isset.UIType ? (out << to_string(UIType)) : (out << "<null>"));
  out << ", " << "devModeOnly="; (__isset.devModeOnly ? (out << to_string(devModeOnly)) : (out << "<null>"));
  out << ", " << "internalOnly="; (__isset.internalOnly ? (out << to_string(internalOnly)) : (out << "<null>"));
  out << ", " << "readOnly="; (__isset.readOnly ? (out << to_string(readOnly)) : (out << "<null>"));
  out << ", " << "isValid=" << to_string(isValid);
  out << ", " << "isActive=" << to_string(isActive);
  out << ", " << "validation="; (__isset.validation ? (out << to_string(validation)) : (out << "<null>"));
  out << ", " << "activeDependencies="; (__isset.activeDependencies ? (out << to_string(activeDependencies)) : (out << "<null>"));
  out << ", " << "ActionName=" << to_string(ActionName);
  out << ", " << "ActionObject=" << to_string(ActionObject);
  out << ", " << "ActionMethodName=" << to_string(ActionMethodName);
  out << ")";
}


SettingCategory::~SettingCategory() throw() {
}


void SettingCategory::__set_id(const std::string& val) {
  this->id = val;
}

void SettingCategory::__set_display(const std::string& val) {
  this->display = val;
}

void SettingCategory::__set_summary(const std::string& val) {
  this->summary = val;
__isset.summary = true;
}

void SettingCategory::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void SettingCategory::__set_sortingPriority(const int32_t val) {
  this->sortingPriority = val;
}

void SettingCategory::__set_isSystemCategory(const bool val) {
  this->isSystemCategory = val;
}

void SettingCategory::__set_items(const std::map<std::string, int32_t> & val) {
  this->items = val;
}

void SettingCategory::__set_enable(const bool val) {
  this->enable = val;
}

void SettingCategory::__set_showInUI(const bool val) {
  this->showInUI = val;
}

uint32_t SettingCategory::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->display);
          this->__isset.display = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->summary);
          this->__isset.summary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sortingPriority);
          this->__isset.sortingPriority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSystemCategory);
          this->__isset.isSystemCategory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->items.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _ktype48;
            ::apache::thrift::protocol::TType _vtype49;
            xfer += iprot->readMapBegin(_ktype48, _vtype49, _size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              std::string _key52;
              xfer += iprot->readString(_key52);
              int32_t& _val53 = this->items[_key52];
              xfer += iprot->readI32(_val53);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.items = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable);
          this->__isset.enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->showInUI);
          this->__isset.showInUI = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SettingCategory::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SettingCategory");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("display", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->display);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.summary) {
    xfer += oprot->writeFieldBegin("summary", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->summary);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("sortingPriority", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->sortingPriority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isSystemCategory", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->isSystemCategory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("items", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->items.size()));
    std::map<std::string, int32_t> ::const_iterator _iter54;
    for (_iter54 = this->items.begin(); _iter54 != this->items.end(); ++_iter54)
    {
      xfer += oprot->writeString(_iter54->first);
      xfer += oprot->writeI32(_iter54->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->enable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("showInUI", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->showInUI);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SettingCategory &a, SettingCategory &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.display, b.display);
  swap(a.summary, b.summary);
  swap(a.description, b.description);
  swap(a.sortingPriority, b.sortingPriority);
  swap(a.isSystemCategory, b.isSystemCategory);
  swap(a.items, b.items);
  swap(a.enable, b.enable);
  swap(a.showInUI, b.showInUI);
  swap(a.__isset, b.__isset);
}

SettingCategory::SettingCategory(const SettingCategory& other55) {
  id = other55.id;
  display = other55.display;
  summary = other55.summary;
  description = other55.description;
  sortingPriority = other55.sortingPriority;
  isSystemCategory = other55.isSystemCategory;
  items = other55.items;
  enable = other55.enable;
  showInUI = other55.showInUI;
  __isset = other55.__isset;
}
SettingCategory& SettingCategory::operator=(const SettingCategory& other56) {
  id = other56.id;
  display = other56.display;
  summary = other56.summary;
  description = other56.description;
  sortingPriority = other56.sortingPriority;
  isSystemCategory = other56.isSystemCategory;
  items = other56.items;
  enable = other56.enable;
  showInUI = other56.showInUI;
  __isset = other56.__isset;
  return *this;
}
void SettingCategory::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SettingCategory(";
  out << "id=" << to_string(id);
  out << ", " << "display=" << to_string(display);
  out << ", " << "summary="; (__isset.summary ? (out << to_string(summary)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "sortingPriority=" << to_string(sortingPriority);
  out << ", " << "isSystemCategory=" << to_string(isSystemCategory);
  out << ", " << "items=" << to_string(items);
  out << ", " << "enable=" << to_string(enable);
  out << ", " << "showInUI=" << to_string(showInUI);
  out << ")";
}


ModuleSetting::~ModuleSetting() throw() {
}


void ModuleSetting::__set_name(const std::string& val) {
  this->name = val;
}

void ModuleSetting::__set_version(const std::string& val) {
  this->version = val;
}

void ModuleSetting::__set_settings(const std::vector<SettingItem> & val) {
  this->settings = val;
}

void ModuleSetting::__set_categories(const std::vector<SettingCategory> & val) {
  this->categories = val;
}

uint32_t ModuleSetting::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->settings.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readListBegin(_etype60, _size57);
            this->settings.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += this->settings[_i61].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.settings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->categories.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->categories.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += this->categories[_i66].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.categories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModuleSetting::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ModuleSetting");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("settings", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->settings.size()));
    std::vector<SettingItem> ::const_iterator _iter67;
    for (_iter67 = this->settings.begin(); _iter67 != this->settings.end(); ++_iter67)
    {
      xfer += (*_iter67).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("categories", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->categories.size()));
    std::vector<SettingCategory> ::const_iterator _iter68;
    for (_iter68 = this->categories.begin(); _iter68 != this->categories.end(); ++_iter68)
    {
      xfer += (*_iter68).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModuleSetting &a, ModuleSetting &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.version, b.version);
  swap(a.settings, b.settings);
  swap(a.categories, b.categories);
  swap(a.__isset, b.__isset);
}

ModuleSetting::ModuleSetting(const ModuleSetting& other69) {
  name = other69.name;
  version = other69.version;
  settings = other69.settings;
  categories = other69.categories;
  __isset = other69.__isset;
}
ModuleSetting& ModuleSetting::operator=(const ModuleSetting& other70) {
  name = other70.name;
  version = other70.version;
  settings = other70.settings;
  categories = other70.categories;
  __isset = other70.__isset;
  return *this;
}
void ModuleSetting::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ModuleSetting(";
  out << "name=" << to_string(name);
  out << ", " << "version=" << to_string(version);
  out << ", " << "settings=" << to_string(settings);
  out << ", " << "categories=" << to_string(categories);
  out << ")";
}


AppDataRecord::~AppDataRecord() throw() {
}


void AppDataRecord::__set_id(const std::string& val) {
  this->id = val;
}

void AppDataRecord::__set_content(const SettingValue& val) {
  this->content = val;
}

uint32_t AppDataRecord::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->content.read(iprot);
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AppDataRecord::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppDataRecord");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->content.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppDataRecord &a, AppDataRecord &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.content, b.content);
  swap(a.__isset, b.__isset);
}

AppDataRecord::AppDataRecord(const AppDataRecord& other71) {
  id = other71.id;
  content = other71.content;
  __isset = other71.__isset;
}
AppDataRecord& AppDataRecord::operator=(const AppDataRecord& other72) {
  id = other72.id;
  content = other72.content;
  __isset = other72.__isset;
  return *this;
}
void AppDataRecord::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppDataRecord(";
  out << "id=" << to_string(id);
  out << ", " << "content=" << to_string(content);
  out << ")";
}


AppDataCollection::~AppDataCollection() throw() {
}


void AppDataCollection::__set_category(const std::string& val) {
  this->category = val;
}

void AppDataCollection::__set_records(const std::vector<AppDataRecord> & val) {
  this->records = val;
}

uint32_t AppDataCollection::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->category);
          this->__isset.category = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->records.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            this->records.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += this->records[_i77].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.records = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AppDataCollection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppDataCollection");

  xfer += oprot->writeFieldBegin("category", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->category);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("records", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->records.size()));
    std::vector<AppDataRecord> ::const_iterator _iter78;
    for (_iter78 = this->records.begin(); _iter78 != this->records.end(); ++_iter78)
    {
      xfer += (*_iter78).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppDataCollection &a, AppDataCollection &b) {
  using ::std::swap;
  swap(a.category, b.category);
  swap(a.records, b.records);
  swap(a.__isset, b.__isset);
}

AppDataCollection::AppDataCollection(const AppDataCollection& other79) {
  category = other79.category;
  records = other79.records;
  __isset = other79.__isset;
}
AppDataCollection& AppDataCollection::operator=(const AppDataCollection& other80) {
  category = other80.category;
  records = other80.records;
  __isset = other80.__isset;
  return *this;
}
void AppDataCollection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppDataCollection(";
  out << "category=" << to_string(category);
  out << ", " << "records=" << to_string(records);
  out << ")";
}


AppData::~AppData() throw() {
}


void AppData::__set_appId(const std::string& val) {
  this->appId = val;
}

void AppData::__set_data(const std::vector<AppDataCollection> & val) {
  this->data = val;
}

uint32_t AppData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appId);
          this->__isset.appId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size81;
            ::apache::thrift::protocol::TType _etype84;
            xfer += iprot->readListBegin(_etype84, _size81);
            this->data.resize(_size81);
            uint32_t _i85;
            for (_i85 = 0; _i85 < _size81; ++_i85)
            {
              xfer += this->data[_i85].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AppData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppData");

  xfer += oprot->writeFieldBegin("appId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->appId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data.size()));
    std::vector<AppDataCollection> ::const_iterator _iter86;
    for (_iter86 = this->data.begin(); _iter86 != this->data.end(); ++_iter86)
    {
      xfer += (*_iter86).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppData &a, AppData &b) {
  using ::std::swap;
  swap(a.appId, b.appId);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

AppData::AppData(const AppData& other87) {
  appId = other87.appId;
  data = other87.data;
  __isset = other87.__isset;
}
AppData& AppData::operator=(const AppData& other88) {
  appId = other88.appId;
  data = other88.data;
  __isset = other88.__isset;
  return *this;
}
void AppData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppData(";
  out << "appId=" << to_string(appId);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


SettingValue::~SettingValue() throw() {
}


void SettingValue::__set_dataType(const std::string& val) {
  this->dataType = val;
}

void SettingValue::__set_dataValue(const std::string& val) {
  this->dataValue = val;
}

uint32_t SettingValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataType);
          this->__isset.dataType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataValue);
          this->__isset.dataValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SettingValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SettingValue");

  xfer += oprot->writeFieldBegin("dataType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataValue", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dataValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SettingValue &a, SettingValue &b) {
  using ::std::swap;
  swap(a.dataType, b.dataType);
  swap(a.dataValue, b.dataValue);
  swap(a.__isset, b.__isset);
}

SettingValue::SettingValue(const SettingValue& other89) {
  dataType = other89.dataType;
  dataValue = other89.dataValue;
  __isset = other89.__isset;
}
SettingValue& SettingValue::operator=(const SettingValue& other90) {
  dataType = other90.dataType;
  dataValue = other90.dataValue;
  __isset = other90.__isset;
  return *this;
}
void SettingValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SettingValue(";
  out << "dataType=" << to_string(dataType);
  out << ", " << "dataValue=" << to_string(dataValue);
  out << ")";
}

}}} // namespace
